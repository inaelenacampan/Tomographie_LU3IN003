<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>methode_complete API documentation</title>
<meta name="description" content="Deuxieme partie : Methode complete de resolution" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>methode_complete</code></h1>
</header>
<section id="section-intro">
<p>Deuxieme partie : Methode complete de resolution</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
    Deuxieme partie : Methode complete de resolution
&#34;&#34;&#34;

from lecture import *
from methode_incomplete import *
from math import *


#Question 13

def Enumeration(G,seq_lignes,seq_colonnes) :
    &#34;&#34;&#34;
        Fontion de resolution complete de l&#39;instance.
        Elle indique si la resolution de l&#39;instance est possible ou non et retourne la matrice coloriee completement.

    &#34;&#34;&#34;

    # dimensions de la matrice (grille)
    N = len(G)
    M = len(G[0])

    # algorithme de propagation
    (ok, new_G_mat) = ColoreGrille(G,seq_lignes,seq_colonnes)

    # le puzzle n&#39;a pas de solution
    if ok == FAUX :
        V = [[VIDE for _ in range(M)] for _ in range(N)]
        return (FAUX,V)

    else :

        # premiere case indeterminee (==VIDE)
        k = CaseIndeterminee(new_G_mat,0)

        # appel recursif avec l&#39;hyp que la case coloriee en blanc
        (ok1, new_G_mat1) = EnumRec(new_G_mat,k,BLANC,seq_lignes,seq_colonnes) 
        if ok1 == VRAI :
            return (ok1, new_G_mat1)

        # car la fonction ne retourne rien si on met en or
        # appel recursif avec l&#39;hyp que la case est coloriee en noir
        (ok2,new_G_mat2) = EnumRec(new_G_mat,k,NOIR,seq_lignes,seq_colonnes)
        if ok2 == VRAI :
            return (ok2, new_G_mat2)

    if ok1 == FAUX and ok2 == FAUX :
        # incoherence, car la case ne peut etre ni blanche, ni noire
        V = [[VIDE for _ in range(M)] for _ in range(N)]
        return (FAUX,V)
    else :
        print(&#34;Erreur : ok1 = &#34;+str(ok1)+&#34; et ok 2 = &#34;+str(ok2))


def EnumRec(G,k,c,seq_lignes,seq_colonnes):
    &#34;&#34;&#34;Fonction qui code l&#39;algorithme recursif d&#39;enumeration.
    Elle indique si la resolution de l&#39;instance est possible ou non et retourne la matrice coloriee.
    La resolution se fait a partir de la permiere case non coloriee.&#34;&#34;&#34;

    # dimensions de la matrice
    N = len(G)
    M = len(G[0])
    if k == N*M :
        return (VRAI,G)

    i = floor(k/M) 
    j = k%M
    (ok, new_G) = ColorierEtPropager(G,i,j,c,seq_lignes,seq_colonnes)

    if ok == FAUX :

        V = [[VIDE for _ in range(M)] for _ in range(N)]
        return (FAUX,V)
    elif ok == VRAI :

        return (VRAI,new_G)
    else :
        # on avance a la prochaine case indeterminee
        new_k = CaseIndeterminee(G,k+1)
        (ok1, new_G_mat1) = EnumRec(new_G,new_k,BLANC,seq_lignes,seq_colonnes)
        if ok1 == VRAI :
            return (ok1, new_G_mat1)


        (ok2,new_G_mat2) = EnumRec(new_G,new_k,NOIR,seq_lignes,seq_colonnes)
        if ok2 == VRAI :
            return (ok2, new_G_mat2)

    if ok1 == FAUX and ok2 == FAUX :
        # incoherence
        V = [[VIDE for _ in range(M)] for _ in range(N)]
        return (FAUX,V)
    else :
        print(&#34;Erreur : ok1 = &#34;+str(ok1)+&#34; et ok 2 = &#34;+str(ok2))


def ColorierEtPropager(G, i, j, c, seq_lignes, seq_colonnes) :
    &#34;&#34;&#34;
        Fonction qui code l&#39;algorithme de propagation pour le coloriage d&#39;une grille en commencant par colorier la case (i,j) par la couleuur c.
        Elle indique si la resolution de l&#39;instance est possible ou non et retourne la matrice coloriee completement ou partiellement.
        Hypothese : la matrice G est partiellement coloriee en entree.
    &#34;&#34;&#34;

    # une structure tres proche de ColoreGrille (la methode partielle de resolution)
    newG = deepcopy(G)
    # dimensions de la matrice(grille)
    N = len(seq_lignes)
    M = len(seq_colonnes)

    # listes de lines et colonnes a voir : au debut de l&#39;algorithme, on doit voir i et j
    LignesAVoir = [i]
    ColonnesAVoir = [j]


    # on commence par colorier la case (i,j) par la couleur c (parametres)
    newG[i][j] = c

    while (LignesAVoir != [] or ColonnesAVoir != []) :

        # on essaye de colorier les lignes
        for i in LignesAVoir :

            # liste des nouvelles colonnes a voir et a rajouter a ColonnesAVoir
            nouveaux_col = []
            (ok,newG)= ColoreLig(newG, M, seq_lignes, i, nouveaux_col)

            # ajout des colonnes
            for x in nouveaux_col :
                if x not in ColonnesAVoir :
                    ColonnesAVoir.append(x)

            LignesAVoir.remove(i)

            # le puzzle n&#39;a pas de solution
            if ok == FAUX : 
                # incoherence trouvee 
                return (FAUX,newG)

        # on essaye de colorier les colonnes
        for j in ColonnesAVoir :

            # liste des nouvelles lignes a voir et a rajouter a LignesAVoir
            nouveaux_lig = []
            (ok, newG) = ColoreCol(newG, N, seq_colonnes, j, nouveaux_lig)

            # ajout des lignes
            for x in nouveaux_lig :
                if x not in LignesAVoir :
                    LignesAVoir.append(x)

            ColonnesAVoir.remove(j)

            # le puzzle n&#39;a pas de solution
            if ok == FAUX : 
                # incoherence trouvee 
                return (FAUX,newG)

    # on teste si la grille est entierement coloriee
    for a in range(N) :
        for b in range(M) :
                if (newG[a][b]==VIDE):
                    return (NESAISPAS,newG)

    return (VRAI,newG)


def CaseIndeterminee(G_mat,k):
    &#34;&#34;&#34;Fonction qui determine la premiere case vide de la grille.&#34;&#34;&#34;

    # on determine les dimensions de la matrice et l&#39;intervalle 
    N = len(G_mat)
    M = len(G_mat[0])
    a = floor(k/M)
    b = k%M

    # on verifice les cases 
    for i in range(a,N) :
        for j in range(b,M):
            if G_mat[i][j] == VIDE :
                return M*i + j

    # cas si aucune case est vide
    return M*N</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="methode_complete.CaseIndeterminee"><code class="name flex">
<span>def <span class="ident">CaseIndeterminee</span></span>(<span>G_mat, k)</span>
</code></dt>
<dd>
<div class="desc"><p>Fonction qui determine la premiere case vide de la grille.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def CaseIndeterminee(G_mat,k):
    &#34;&#34;&#34;Fonction qui determine la premiere case vide de la grille.&#34;&#34;&#34;

    # on determine les dimensions de la matrice et l&#39;intervalle 
    N = len(G_mat)
    M = len(G_mat[0])
    a = floor(k/M)
    b = k%M

    # on verifice les cases 
    for i in range(a,N) :
        for j in range(b,M):
            if G_mat[i][j] == VIDE :
                return M*i + j

    # cas si aucune case est vide
    return M*N</code></pre>
</details>
</dd>
<dt id="methode_complete.ColorierEtPropager"><code class="name flex">
<span>def <span class="ident">ColorierEtPropager</span></span>(<span>G, i, j, c, seq_lignes, seq_colonnes)</span>
</code></dt>
<dd>
<div class="desc"><p>Fonction qui code l'algorithme de propagation pour le coloriage d'une grille en commencant par colorier la case (i,j) par la couleuur c.
Elle indique si la resolution de l'instance est possible ou non et retourne la matrice coloriee completement ou partiellement.
Hypothese : la matrice G est partiellement coloriee en entree.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ColorierEtPropager(G, i, j, c, seq_lignes, seq_colonnes) :
    &#34;&#34;&#34;
        Fonction qui code l&#39;algorithme de propagation pour le coloriage d&#39;une grille en commencant par colorier la case (i,j) par la couleuur c.
        Elle indique si la resolution de l&#39;instance est possible ou non et retourne la matrice coloriee completement ou partiellement.
        Hypothese : la matrice G est partiellement coloriee en entree.
    &#34;&#34;&#34;

    # une structure tres proche de ColoreGrille (la methode partielle de resolution)
    newG = deepcopy(G)
    # dimensions de la matrice(grille)
    N = len(seq_lignes)
    M = len(seq_colonnes)

    # listes de lines et colonnes a voir : au debut de l&#39;algorithme, on doit voir i et j
    LignesAVoir = [i]
    ColonnesAVoir = [j]


    # on commence par colorier la case (i,j) par la couleur c (parametres)
    newG[i][j] = c

    while (LignesAVoir != [] or ColonnesAVoir != []) :

        # on essaye de colorier les lignes
        for i in LignesAVoir :

            # liste des nouvelles colonnes a voir et a rajouter a ColonnesAVoir
            nouveaux_col = []
            (ok,newG)= ColoreLig(newG, M, seq_lignes, i, nouveaux_col)

            # ajout des colonnes
            for x in nouveaux_col :
                if x not in ColonnesAVoir :
                    ColonnesAVoir.append(x)

            LignesAVoir.remove(i)

            # le puzzle n&#39;a pas de solution
            if ok == FAUX : 
                # incoherence trouvee 
                return (FAUX,newG)

        # on essaye de colorier les colonnes
        for j in ColonnesAVoir :

            # liste des nouvelles lignes a voir et a rajouter a LignesAVoir
            nouveaux_lig = []
            (ok, newG) = ColoreCol(newG, N, seq_colonnes, j, nouveaux_lig)

            # ajout des lignes
            for x in nouveaux_lig :
                if x not in LignesAVoir :
                    LignesAVoir.append(x)

            ColonnesAVoir.remove(j)

            # le puzzle n&#39;a pas de solution
            if ok == FAUX : 
                # incoherence trouvee 
                return (FAUX,newG)

    # on teste si la grille est entierement coloriee
    for a in range(N) :
        for b in range(M) :
                if (newG[a][b]==VIDE):
                    return (NESAISPAS,newG)

    return (VRAI,newG)</code></pre>
</details>
</dd>
<dt id="methode_complete.EnumRec"><code class="name flex">
<span>def <span class="ident">EnumRec</span></span>(<span>G, k, c, seq_lignes, seq_colonnes)</span>
</code></dt>
<dd>
<div class="desc"><p>Fonction qui code l'algorithme recursif d'enumeration.
Elle indique si la resolution de l'instance est possible ou non et retourne la matrice coloriee.
La resolution se fait a partir de la permiere case non coloriee.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def EnumRec(G,k,c,seq_lignes,seq_colonnes):
    &#34;&#34;&#34;Fonction qui code l&#39;algorithme recursif d&#39;enumeration.
    Elle indique si la resolution de l&#39;instance est possible ou non et retourne la matrice coloriee.
    La resolution se fait a partir de la permiere case non coloriee.&#34;&#34;&#34;

    # dimensions de la matrice
    N = len(G)
    M = len(G[0])
    if k == N*M :
        return (VRAI,G)

    i = floor(k/M) 
    j = k%M
    (ok, new_G) = ColorierEtPropager(G,i,j,c,seq_lignes,seq_colonnes)

    if ok == FAUX :

        V = [[VIDE for _ in range(M)] for _ in range(N)]
        return (FAUX,V)
    elif ok == VRAI :

        return (VRAI,new_G)
    else :
        # on avance a la prochaine case indeterminee
        new_k = CaseIndeterminee(G,k+1)
        (ok1, new_G_mat1) = EnumRec(new_G,new_k,BLANC,seq_lignes,seq_colonnes)
        if ok1 == VRAI :
            return (ok1, new_G_mat1)


        (ok2,new_G_mat2) = EnumRec(new_G,new_k,NOIR,seq_lignes,seq_colonnes)
        if ok2 == VRAI :
            return (ok2, new_G_mat2)

    if ok1 == FAUX and ok2 == FAUX :
        # incoherence
        V = [[VIDE for _ in range(M)] for _ in range(N)]
        return (FAUX,V)
    else :
        print(&#34;Erreur : ok1 = &#34;+str(ok1)+&#34; et ok 2 = &#34;+str(ok2))</code></pre>
</details>
</dd>
<dt id="methode_complete.Enumeration"><code class="name flex">
<span>def <span class="ident">Enumeration</span></span>(<span>G, seq_lignes, seq_colonnes)</span>
</code></dt>
<dd>
<div class="desc"><p>Fontion de resolution complete de l'instance.
Elle indique si la resolution de l'instance est possible ou non et retourne la matrice coloriee completement.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Enumeration(G,seq_lignes,seq_colonnes) :
    &#34;&#34;&#34;
        Fontion de resolution complete de l&#39;instance.
        Elle indique si la resolution de l&#39;instance est possible ou non et retourne la matrice coloriee completement.

    &#34;&#34;&#34;

    # dimensions de la matrice (grille)
    N = len(G)
    M = len(G[0])

    # algorithme de propagation
    (ok, new_G_mat) = ColoreGrille(G,seq_lignes,seq_colonnes)

    # le puzzle n&#39;a pas de solution
    if ok == FAUX :
        V = [[VIDE for _ in range(M)] for _ in range(N)]
        return (FAUX,V)

    else :

        # premiere case indeterminee (==VIDE)
        k = CaseIndeterminee(new_G_mat,0)

        # appel recursif avec l&#39;hyp que la case coloriee en blanc
        (ok1, new_G_mat1) = EnumRec(new_G_mat,k,BLANC,seq_lignes,seq_colonnes) 
        if ok1 == VRAI :
            return (ok1, new_G_mat1)

        # car la fonction ne retourne rien si on met en or
        # appel recursif avec l&#39;hyp que la case est coloriee en noir
        (ok2,new_G_mat2) = EnumRec(new_G_mat,k,NOIR,seq_lignes,seq_colonnes)
        if ok2 == VRAI :
            return (ok2, new_G_mat2)

    if ok1 == FAUX and ok2 == FAUX :
        # incoherence, car la case ne peut etre ni blanche, ni noire
        V = [[VIDE for _ in range(M)] for _ in range(N)]
        return (FAUX,V)
    else :
        print(&#34;Erreur : ok1 = &#34;+str(ok1)+&#34; et ok 2 = &#34;+str(ok2))</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="methode_complete.CaseIndeterminee" href="#methode_complete.CaseIndeterminee">CaseIndeterminee</a></code></li>
<li><code><a title="methode_complete.ColorierEtPropager" href="#methode_complete.ColorierEtPropager">ColorierEtPropager</a></code></li>
<li><code><a title="methode_complete.EnumRec" href="#methode_complete.EnumRec">EnumRec</a></code></li>
<li><code><a title="methode_complete.Enumeration" href="#methode_complete.Enumeration">Enumeration</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>